//flatten a tree to linked list
#include<bits/stdc++.h>
using namespace std;

class node{                             // class to represent tree
public:
    int data;                           // data of the node of the tree
    node* left;                         // left pointer of the node        
    node* right;                        // Right pointer of the node
    node(int val){                      // constructor of the node to generate the node
        data = val;                     // the input of data is taken to be value
        left = NULL;                    // left pointer is defined as NULL
        right = NULL;                   // Right pointer is defined as NULL
    }
};

void flatten(node* root){               // function to flatten taking input as a node root of the tree which was generated by the user

    if(root == NULL || (root->left == NULL && root->right == NULL))// if root is null or a leaf node then we just simply return as nothing 
        return ;                                                   // can be done/ tree is already flattend 

    if(root->left != NULL){             // if left node of root is not null then we call the function                                                      
        flatten(root->left);            // recursive call for the function, now utililzing the left part of the function

        node* temp = root->right;       // making the right part of the tree as a variable temp
        root->right = root->left;       // making the left node of the tree as the right node || redo of healer level bullshit
        root->left = NULL;              // making the left part of the node as NULL because it is AQUA(useless !)

        node* t = root->right;          // taking a variable t as the remaining right of node which was originally the left part
        while(t->right != NULL){        // traversing from the variable t to the last node of the tree which is in the right part
            t = t->right;
        }

        t->right = temp;                // after reaching we assign the right part of the tree to the right of the leaf node of the left part
    }

    flatten(root->right);               // calling for the right part of the tree after completing the left part of the tree
}

void inOrderTraversal(node* root){
    if(root==NULL)
        return;
    
    inOrderTraversal(root->left);
    cout<<root->data<<" ";
    inOrderTraversal(root->right);
}

int main(){
    node* root = new node(4);
    root->left = new node(9);
    root->right = new node(5);
    root->left->left = new node(1);
    root->left->right = new node(3);
    root->right->right = new node(6);

    flatten(root);
    inOrderTraversal(root);
    return 0;
}